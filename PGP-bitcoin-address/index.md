#  Using GPG as a Bitcoin addess

## Introduction

Provide an introduction to the purpose or subject being covered in this tutorial

Considering GnuPG did add secp256k1 elliptic curve support early 2014 and the recent merge of [BIP174](https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki) enabling partially signed bitcoin transaction (PSBT), it became plausible to use OpenPGP cards to store bitcoin private key in the tamper-resistant and PIN-protected device. This tutorial will guide you through experimenting with GnuPG and raw bitcoin transaction.

## Background

Provide some background as to what problem will be addressed or what motivated writing this tutorial.

This tutorial is written to share experience, as an experimentation. We will demonstrate how to derive a bitcoin address from a PGP public key, create a bitcoin transaction, sign it with corresponding private key and finally broadcast it to the network.
We will be using GnuPG v2.2.12 and Julia v1.1

## Let's get started

### Generate a key pair

We first have to create a key pair with GnuPG, using ECC and scep256k1 curve. We will simply run gpg with the `--full-generate-key` command and `--expert` option. Once in GnuPG interactive menu, select option `10`, `9`, `0`, `y` and finalize with user detail at your will.


```
$ gpg --expert --full-generate-key
gpg (GnuPG) 2.2.12; Copyright (C) 2018 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Please select what kind of key you want:
   (1) RSA and RSA (default)
   (2) DSA and Elgamal
   (3) DSA (sign only)
   (4) RSA (sign only)
   (7) DSA (set your own capabilities)
   (8) RSA (set your own capabilities)
   (9) ECC and ECC
  (10) ECC (sign only)
  (11) ECC (set your own capabilities)
  (13) Existing key
Your selection? 10
Please select which elliptic curve you want:
   (1) Curve 25519
   (3) NIST P-256
   (4) NIST P-384
   (5) NIST P-521
   (6) Brainpool P-256
   (7) Brainpool P-384
   (8) Brainpool P-512
   (9) secp256k1
Your selection? 9
Please specify how long the key should be valid.
         0 = key does not expire
      <n>  = key expires in n days
      <n>w = key expires in n weeks
      <n>m = key expires in n months
      <n>y = key expires in n years
Key is valid for? (0) 0
Key does not expire at all
Is this correct? (y/N) y

GnuPG needs to construct a user ID to identify your key.

Real name: bitcoin pgp 001
Email address:
Comment:
You selected this USER-ID:
    "bitcoin pgp 001"

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O
We need to generate a lot of random bytes. It is a good idea to perform
some other action (type on the keyboard, move the mouse, utilize the
disks) during the prime generation; this gives the random number
generator a better chance to gain enough entropy.
gpg: key 8FAB2B40D753C0F6 marked as ultimately trusted
gpg: revocation certificate stored as '/home/simon/.gnupg/openpgp-revocs.d/1F6132045B4B6C393C48846E8FAB2B40D753C0F6.rev'
public and secret key created and signed.

pub   secp256k1 2019-02-13 [SC]
      1F6132045B4B6C393C48846E8FAB2B40D753C0F6
uid                      bitcoin pgp 001

```

### Export Public Key

We can then export the public key we just generated by first generating a bynary file with GnuPG and parsing its content with julia (python or any oher language would most likely achieve the same).
Extract binary with GnuPG is straigth forward and can be done with the following commande.

```
$ gpg --output pubkey.bin --export 8FAB2B40D753C0F6
```

Parsing the resulting file requires going through [RFC4880bis](https://tools.ietf.org/html/draft-ietf-openpgp-rfc4880bis-06) which is rather long and off topic this tutorial. We will just use the function `bin2packet` which interprets PGP messages and allows to extract ECDSA keys and signature. Source code of the later function can be found at [GitLab](https://gitlab.com/braneproject/pgpacket.jl), note that it is highly experimental and untested, use at your own risk!

With public key packet we are able to extract a point on an scep256k1 curve.

```
julia> packet = bin2packet("pubkey.bin")[1]
3-element Array{PGPPacket,1}:
 Public-Key Packet
 Length : 79, Partial : false
PublicKey(0x04, 1550079457, scep256k1 Point(洧논,洧녽):
f05314566c9bfc8d8cf463a7a01e7735245d588a60dd874f09a9636620abb314,
6bda245d43cbbe019ab1ad74316d675dd858cdd776820969bcc21bbccbd3a661)

julia> pubkey = packets[1].body.point
scep256k1 Point(洧논,洧녽):
f05314566c9bfc8d8cf463a7a01e7735245d588a60dd874f09a9636620abb314,
6bda245d43cbbe019ab1ad74316d675dd858cdd776820969bcc21bbccbd3a661
```

From that public key, we can just compute the correspondingbitcoin address using `Bitcoin` package in Julia. We are here using true as second and third function argument to generate a compressed address on testnet.

```
julia> using Bitcoin

julia> address(pubkey, true, true)
"moZ5AGrmGEFD4rCgSK2Vau46RjjsZpgmNo"
 ```

We now have a bitcoin testnet address derived from GPG public key!

### Construct transaction

First send some bitcoin to your test address and use a block explorer to identify incoming transaction. In this case it is transaction [bf...47](https://live.blockcypher.com/btc-testnet/tx/bfd8209364e0fe275c30829391207d89fc1c480c6148caf37e5d612728f43247/) at index 0.
Create transaction input

```
julia> tx_ins = TxIn[];
julia> prev_tx = hex2bytes("bfd8209364e0fe275c30829391207d89fc1c480c6148caf37e5d612728f43247");
julia> push!(tx_ins, TxIn(prev_tx, 0));
```

We then need to create transaction outputs, one to a destination address.

```
julia> target_address = b"mv4rnyY3Su5gjcDNzbMLKBQkBicCtHUtFB";
julia> tx_outs = TxOut[];
julia> h160 = base58checkdecode(target_address)[2:end];
julia> script_pubkey = p2pkh_script(h160);
julia> target_amount = 0.01;
julia> target_satoshis = Int(target_amount*100000000);
julia> push!(tx_outs, TxOut(target_satoshis, script_pubkey));
```

And the change back to the same address, for convinience purpose.

```
julia> change_address = b"moZ5AGrmGEFD4rCgSK2Vau46RjjsZpgmNo";
julia> h160 = base58checkdecode(change_address)[2:end];
julia> script_pubkey = p2pkh_script(h160);
julia> prev_amount = txinvalue(tx_ins[1], true);
julia> fee = 50000;
julia> change_satoshis = prev_amount - target_satoshis - fee;
julia> push!(tx_outs, TxOut(change_satoshis, script_pubkey));
```

Finally, we can contruct our unsigned transaction with one input and two outputs.

```
julia> tx_obj = Tx(1, tx_ins, tx_outs, 0, true)
Transaction
--------
Testnet : true
Version : 1
Locktime : 0
--------

TxIn[
bfd8209364e0fe275c30829391207d89fc1c480c6148caf37e5d612728f43247:0
]
--------

TxOut[

OP_DUP
OP_HASH160
9f9a7abd600c0caa03983a77c8c3df8e062cb2fa
OP_EQUALVERIFY
OP_CHECKSIG
amout (BTC) : 0.01,

OP_DUP
OP_HASH160
582791ccb518faac5dd16290d7b65484ce416fa3
OP_EQUALVERIFY
OP_CHECKSIG
amout (BTC) : 0.178785]
```

### Sign transaction

Once we have our unsigned bitcoin transaction we can compute `z` which will be signed using GPG private key

```
julia> z = txsighash(tx_obj, input_index)
99621552382283238930643867389539606415724582999531180113553721867524305282175
```

Unfortunately OpenPGP signing algorithm implies [adding a trailer to `z` and hash that all together](https://tools.ietf.org/html/draft-ietf-openpgp-rfc4880bis-06#section-5.2.4). This will result in a totally different signature which prevents us from using GnuPG signature at the moment. We will therefore export the private key from GnuPG and use it to sign the transaction with our Bitcoin package.

```
$ gpg --export-secret-key --output privkey.bin D753C0F6
```

We can then parse the resulting binary file as follows.

```
julia> packet = bin2packet("privkey.bin")[1]
Secret-Key Packet
 Length : 116, partial : false
 ----------------
  Version : 4, Time : 2019-02-13T17:37:37
 Algorithm : ECDSA public key algorithm [FIPS186] using scep256k1
 scep256k1 Point(洧논,洧녽):
f05314566c9bfc8d8cf463a7a01e7735245d588a60dd874f09a9636620abb314,
6bda245d43cbbe019ab1ad74316d675dd858cdd776820969bcc21bbccbd3a661
 Specifics : Any[0x00, "Plaintext or unencrypted data", nothing, 103000258811017069236190011207690036914755247769939851615254124923965391038974]

julia> secret = packet.body.specifics[4];

julia> pk = PrivateKey(secret)
PrivateKey(103000258811017069236190011207690036914755247769939851615254124923965391038974, scep256k1 Point(洧논,洧녽):
f05314566c9bfc8d8cf463a7a01e7735245d588a60dd874f09a9636620abb314,
6bda245d43cbbe019ab1ad74316d675dd858cdd776820969bcc21bbccbd3a661)
```

Once in possession of the private key and `z` we can compute signature as follows, push it to the transaction which we can serialize and finally broadcast it.

```
julia> sig = pksign(pk, z)
scep256k1 signature(洧, 洧):
1413a5458e10a8d3419b9f534179a5367875ee390722b286612101ddbbdd1e4e,
5d449bd818bafc5f25d0fcd17536b4554eb0245879585fe8fd24c13c906d6122

julia> txpushsignature(tx_obj, 0, z, sig, pubkey)
true

julia> bytes2hex(txserialize(tx_obj))
"01000000014732f42827615d7ef3ca48610c481cfc897d20919382305c27fee0649320d8bf000000006b4830450221009ac61e75c35cbb282e98bd08b3206e3436570be357f886bf85e8964db3681f670220286590134b392f4e7cb03431a5aefc519c91cdbbb50e27681da43e47d74b73ae012103f05314566c9bfc8d8cf463a7a01e7735245d588a60dd874f09a9636620abb314ffffffff0240420f00000000001976a9149f9a7abd600c0caa03983a77c8c3df8e062cb2fa88ace9cd1001000000001976a914582791ccb518faac5dd16290d7b65484ce416fa388ac00000000"
```

See resulting transaction [1a...32](https://live.blockcypher.com/btc-testnet/tx/1a5b4504419857c369c753cb0b85068de39e55d4666cda57430c43fe1506f132/)

## Conclusion

We have sucessfully derived a bitcoin address from a GPG public key, created a raw transaction and signed it with GPG private key. Unfortunately, we were not able to sign a bitcoin transaction directly with GPG due to its specific signing algorithm. Next step may require customizing GnuPG code to create a specific signing algorithm that would work for bitcoin.


## Reference

Provide any references related to this tutorial.

OpenPGP message format - [RFC4880bis](https://tools.ietf.org/html/draft-ietf-openpgp-rfc4880bis-06)
`bin2packet` function - [PGPPacket](https://gitlab.com/braneproject/pgpacket.jl)
Bitcoin package - [Bitcoin.jl](https://gitlab.com/braneproject/Bitcoin.jl)
